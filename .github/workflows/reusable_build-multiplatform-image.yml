name: Build Multiplatform Image
on:
  workflow_call:
    inputs:
      if-absent:
        description: "A boolean value that indicates whether or not the image should be built only when there's no existing image."
        type: boolean
        required: false
        default: true
      context:
        description: "Build Context"
        type: string
        required: false
        default: "."
      dockerfile:
        description: "Path to the Dockerfile"
        type: string
        required: false
      build-args:
        description: "Build Arguments"
        type: string
        required: false
        default: ""
      registry:
        description: "Docker Registry"
        type: string
        required: false
        default: ""
      username:
        description: "User Name for Docker Registry"
        type: string
        required: false
        default: ""
      image-basename:
        description: "Image Base Name"
        type: string
        required: true
      tags:
        description: "Tag Names (List separated by newlines)"
        type: string
        required: true
      cache-file-path:
        description: "Path to file/directory to be restored/saved using `actions/cache`."
        type: string
        required: false
        default: ""
      cache-file-key-suffix:
        description: "Suffix that is added to `key` parameter of `action/cache`."
        type: string
        required: false
      set-up-command:
        description: "Command to be executed before building the image."
        type: string
        required: false
        default: ""
      set-up-command-shell:
        description: "Shell to execute the command: `bash` or `zsh`."
        type: string
        required: false
        default: "bash"
      set-up-script:
        description: "Script to be executed before building the image"
        type: string
        required: false
        default: ""
      test-command:
        description: "Command to be executed after building the image and before pushing it"
        type: string
        required: false
        default: ""
      test-command-shell:
        description: "Shell to execute the command: `bash` or `zsh`."
        type: string
        required: false
        default: "bash"
      test-script:
        description: "Script to be executed after building the image and before pushing it"
        type: string
        required: false
        default: ""
      push:
        description: "A boolean value indicating whether or not the image is pushed"
        type: boolean
        required: true
        default: false
    secrets:
      password:
        description: "Password to login Docker Registry"
        required: false
    outputs:
      all-skipped:
        value: ${{ jobs.generate-results.outputs.all-skipped }}
      results:
        value: ${{ jobs.generate-results.outputs.results }}
      resultsJSON:
        value: ${{ jobs.generate-results.outputs.resultsJSON }}
      preferred-image-tag:
        value: ${{ jobs.generate-results.outputs.preferred-image-tag }}
jobs:
  prepare:
    name: Prepare for building images.
    runs-on: ubuntu-latest
    steps:
      - name: Generate Image Name Info
        id: image-name-info
        env:
          D_REGISTRY: ${{ inputs.registry }}
          D_USERNAME: ${{ inputs.username }}
          D_IMAGE_BASENAME: ${{ inputs.image-basename }}
          D_TAGS: ${{ inputs.tags }}
        shell: bash
        run: |
          set -eu

          if [[ -z "$D_IMAGE_BASENAME" ]]; then
            echo '::error title=Missing image name::No image base name was given.'
            exit 1
          fi

          declare image_namespace=""
          if [[ -n "$D_REGISTRY" ]]; then
            image_namespace="${image_namespace}${D_REGISTRY,,}/"
          fi
          if [[ -n "$D_USERNAME" ]]; then
            image_namespace="${image_namespace}${D_USERNAME,,}/"
          fi
          image_namespace="${image_namespace%%/}"

          declare full_image_name="${image_namespace}/${D_IMAGE_BASENAME,,}"
          full_image_name="${full_image_name##/}"
          if [[ -z "$full_image_name" ]]; then
            echo '::error::Empty Image Name.'
            exit 1
          fi

          echo "image_namespace=$image_namespace" >>"$GITHUB_OUTPUT"
          echo "full_image_name=$full_image_name" >>"$GITHUB_OUTPUT"

          declare tagExists="false"
          declare tagLine
          echo "all_tags<<__ALL_TAGS__" >>"$GITHUB_OUTPUT"
          while IFS= read -r tagLine; do
            # Trimming...
            declare trimmedTag=$(echo "$tagLine" | xargs)
            if [[ -n "$trimmedTag" ]]; then
              tagExists="true"
              echo "$trimmedTag" >>"$GITHUB_OUTPUT"
            fi
          done < <(echo "$D_TAGS" | sort -u | awk NF)
          echo "__ALL_TAGS__" >>"$GITHUB_OUTPUT"

          if [[ "$tagExists" == "false" ]]; then
            echo '::error::No valid tags are given.'
            exit 1
          fi
      - name: Log in to the Container registry
        env:
          password: ${{ secrets.password }}
        if: ${{ inputs.username != '' && env.password != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.username }}
          password: ${{ secrets.password }}
      - name: Determine which image should be built
        id: should-build
        env:
          IF_ABSENT: ${{ (inputs.if-absent && 'true') || 'false' }}
          FULL_IMAGE_NAME: ${{ steps.image-name-info.outputs.full_image_name }}
          ALL_TAGS: ${{ steps.image-name-info.outputs.all_tags }}
        shell: bash
        run: |
          declare should_build="false"
          declare -r tagsToBuildOutput=$(mktemp)
          if [[ "$IF_ABSENT" != "true" ]]; then
            echo "$ALL_TAGS" >>"$tagsToBuildOutput"
            should_build="true"
          else
            set +e
            declare tagLine
            while IFS= read -r tagLine; do
              if [[ "$tagLine" == *latest* ]]; then
                echo "$tagLine" >>"$tagsToBuildOutput"
                should_build="true"
              else
                docker manifest inspect "${FULL_IMAGE_NAME}:${tagLine}"
                if [[ $? -ne 0 ]]; then
                  echo "$tagLine" >>"$tagsToBuildOutput"
                  should_build="true"
                fi
              fi
            done < <(echo "$ALL_TAGS")
          fi

          echo "should_build=$should_build" >>"$GITHUB_OUTPUT"
          echo "tags_to_build<<__TAGS_TO_BUILD__" >>"$GITHUB_OUTPUT"
          cat "$tagsToBuildOutput" >>"$GITHUB_OUTPUT"
          echo "__TAGS_TO_BUILD__" >>"$GITHUB_OUTPUT"
    outputs:
      image_namespace: ${{ steps.image-name-info.outputs.image_namespace }}
      full_image_name: ${{ steps.image-name-info.outputs.full_image_name }}
      all_tags: ${{ steps.image-name-info.outputs.all_tags }}
      should_build: ${{ steps.should-build.outputs.should_build }}
      tags_to_build: ${{ steps.should-build.outputs.tags_to_build }}
  build-images:
    name: Build Images (if necessary)
    needs: 
      - prepare
    if: ${{ needs.prepare.outputs.should_build == 'true' }}
    env:
      password: ${{ secrets.password }}
    strategy:
      matrix:
        host-os:
          - ubuntu-24.04
          - ubuntu-24.04-arm
    runs-on: ${{ matrix.host-os }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Detect 'arch' and 'platform'
        id: arch-and-platform
        run: |
          case "$(dpkg --print-architecture)" in
          amd64)
            echo "arch=amd64" >>"$GITHUB_OUTPUT"
            echo "platform=linux/amd64" >>"$GITHUB_OUTPUT"
          ;;
          arm64)
            echo "arch=arm64" >>"$GITHUB_OUTPUT"
            echo "platform=linux/arm64" >>"$GITHUB_OUTPUT"
          ;;
          *)
            echo '::error::Unsupported architecture.'
            exit 1
          ;;
          esac
      - name: "Generate `tags` argument for 'docker/metadata-action'"
        id: tags-for-metadata-action
        env:
          D_TAGS: ${{ needs.prepare.outputs.tags_to_build }}
          D_ARCH: ${{ steps.arch-and-platform.outputs.arch }}
        shell: bash
        run: |
          echo "tags<<__TAGS__" >>"$GITHUB_OUTPUT"
          declare tag
          while IFS= read -r tag; do
            echo "type=raw,value=${tag}-${D_ARCH}" >>"$GITHUB_OUTPUT"
          done < <(echo "$D_TAGS")
          echo "__TAGS__" >>"$GITHUB_OUTPUT"
      - name: Generate a tag for tests
        id: test-tag
        shell: bash
        run: |
          declare -r generated_uuid=$(uuidgen)
          echo "test_tag=test-${generated_uuid,,}" >>"$GITHUB_OUTPUT"
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to the Container registry
        if: ${{ inputs.username != '' && env.password != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.username }}
          password: ${{ secrets.password }}
      - name: Generate Cache File Keys (if necessary)
        if: ${{ inputs.cache-file-path != '' }}
        id: cache-file-keys
        env:
          ALL_TAGS: ${{ needs.prepare.outputs.all_tags }}
          D_ARCH: ${{ steps.arch-and-platform.outputs.arch }}
          FULL_IMAGE_NAME: ${{ needs.prepare.outputs.full_image_name }}
          KEY_SUFFIX: ${{ inputs.cache-file-key-suffix }}
          TAGS_TO_BUILD: ${{ needs.prepare.outputs.tags_to_build }}
        run: |
          set -eu

          declare -r keyPrefix="${D_ARCH}-${FULL_IMAGE_NAME}"
          declare -r firstTag=$(echo "$TAGS_TO_BUILD" | head -n 1)
          declare -r primaryKey="${keyPrefix}-${firstTag}-${KEY_SUFFIX}"; echo "::debug::Primary Key is '${primaryKey}'."
          echo "key=${primaryKey}" >>"$GITHUB_OUTPUT"

          echo "restore-keys<<__RESTORE_KEYS__" >>"$GITHUB_OUTPUT"

          declare aKey="$primaryKey"
          declare -r shortestKey="${keyPrefix}-${firstTag}-"; echo "::debug::Expected shortest key generated from the primary key is '${shortestKey}'."
          declare -r shortestKeyLength=$(echo "$shortestKey" | wc -c | xargs); echo "::debug::The length of the shortest key is ${shortestKeyLength}."
          while : ; do
            aKey=$(echo "${aKey%-}" | sed -E 's/-[^\-]+$/-/'); echo "::debug::Next restore key is '${aKey}'."
            if [[ $(( $(echo "$aKey" | wc -c) + 0 )) -le $(( $shortestKeyLength + 0 )) ]]; then
              echo "::debug::'$aKey' is too short."
              break
            fi
            echo "$aKey" >>"$GITHUB_OUTPUT"
          done

          declare aTag
          while IFS= read -r aTag; do
            aKey="${keyPrefix}-${aTag}-"; echo "::debug::Next restore key is '${aKey}'."
            echo "$aKey" >>"$GITHUB_OUTPUT"
          done < <(echo "$ALL_TAGS")
          echo "${keyPrefix}-" >>"$GITHUB_OUTPUT"

          echo "__RESTORE_KEYS__" >>"$GITHUB_OUTPUT"
      - name: Restore Cache (if necessary)
        if: ${{ inputs.cache-file-path != '' }}
        uses: actions/cache@v4
        with:
          path: ${{ inputs.cache-file-path }}
          key: ${{ steps.cache-file-keys.outputs.key }}
          restore-keys: ${{ steps.cache-file-keys.outputs.restore-keys }}
      - name: Set Up (Command)
        if: ${{ inputs.set-up-command != '' }}
        # Workaround for 'shell' not taking `${{ ... }}`
        env:
          SET_UP_COMMAND_SHELL: ${{ inputs.set-up-command-shell }}
          SET_UP_COMMAND: ${{ inputs.set-up-command }}
        run: |
          case "$SET_UP_COMMAND_SHELL" in
          bash)
            bash -c "$SET_UP_COMMAND"
          ;;
          zsh)
            sudo apt update && sudo apt install zsh
            zsh -c "$SET_UP_COMMAND"
          ;;
          *)
            echo '::error::Unsupported shell.'
            exit 1
          ;;
          esac
      - name: Set Up (Script File)
        if: ${{ inputs.set-up-script != '' }}
        run: |
          if [[ ! -f "${{ inputs.set-up-script }}" ]]; then
            echo '::error title=Missing set-up script::Script file not found.'
            exit 1
          fi
          chmod a+x "${{ inputs.set-up-script }}"
          "${{ inputs.set-up-script }}"
      - name: Extract metadata (tags, labels) for Docker
        id: metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.prepare.outputs.full_image_name }}
          tags: ${{ steps.tags-for-metadata-action.outputs.tags }}
      - name: Build Image
        id: build-image
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          build-args: ${{ inputs.build-args }}
          platforms: ${{ steps.arch-and-platform.outputs.platform }}
          load: true
          push: false
          tags: |
            ${{ steps.metadata.outputs.tags }}
            ${{ needs.prepare.outputs.full_image_name }}:${{ steps.test-tag.outputs.test_tag }}
          labels: ${{ steps.metadata.outputs.labels }}
          provenance: false
          sbom: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Test Image (Command)
        if: ${{ inputs.test-command != '' }}
        # Workaround for 'shell' not taking `${{ ... }}`
        env:
          TEST_COMMAND_SHELL: ${{ inputs.test-command-shell }}
          TEST_COMMAND: ${{ inputs.test-command }}
          DOCKER_TEST_TAG: "${{ needs.prepare.outputs.full_image_name }}:${{ steps.test-tag.outputs.test_tag }}"
        run: |
          case "$TEST_COMMAND_SHELL" in
          bash)
            bash -c "$TEST_COMMAND"
          ;;
          zsh)
            sudo apt update && sudo apt install zsh
            zsh -c "$TEST_COMMAND"
          ;;
          *)
            echo '::error::Unsupported shell.'
            exit 1
          ;;
          esac
      - name: Test Image (Script File)
        if: ${{ inputs.test-script != '' }}
        env:
          DOCKER_TEST_TAG: "${{ needs.prepare.outputs.full_image_name }}:${{ steps.test-tag.outputs.test_tag }}"
        run: |
          if [[ ! -f "${{ inputs.test-script }}" ]]; then
            echo '::error title=Missing test script::Script file not found.'
            exit 1
          fi
          chmod a+x "${{ inputs.test-script }}"
          "${{ inputs.test-script }}"
      - name: Push Image
        id: push-image
        if: ${{ inputs.push }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          build-args: ${{ inputs.build-args }}
          platforms: ${{ steps.arch-and-platform.outputs.platform }}
          load: false
          push: true
          tags: ${{ steps.metadata.outputs.tags }}
          labels: ${{ steps.metadata.outputs.labels }}
          provenance: false
          sbom: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
  merge-images:
    name: Merge Images (if necessary)
    needs:
      - prepare
      - build-images
    if: ${{ inputs.push && needs.prepare.outputs.should_build == 'true' }}
    runs-on:
      - ubuntu-latest
    env:
      password: ${{ secrets.password }}
    steps:
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to the Container registry
        if: ${{ inputs.username != '' && env.password != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.username }}
          password: ${{ secrets.password }}
      - name: Merge Images
        env:
          FULL_IMAGE_NAME: ${{ needs.prepare.outputs.full_image_name }}
          BUILT_TAGS: ${{ needs.prepare.outputs.tags_to_build }}
        shell: bash
        run: |
          declare tagLine
          declare full_image_tag
          while IFS= read -r tagLine; do
            full_image_tag="${FULL_IMAGE_NAME}:${tagLine}"
            docker manifest create "$full_image_tag" \
              "${full_image_tag}-amd64" \
              "${full_image_tag}-arm64"
            docker manifest annotate "$full_image_tag" \
              "${full_image_tag}-amd64" --os linux --arch amd64
            docker manifest annotate "$full_image_tag" \
              "${full_image_tag}-arm64" --os linux --arch arm64
            docker manifest push "$full_image_tag"
          done < <(echo "$BUILT_TAGS")
  generate-results:
    name: Generate Results
    needs:
      - prepare
      - merge-images
    if: ${{ ! failure() }}
    runs-on: ubuntu-latest
    steps:
      - name: Generate Results
        id: generate-results
        env:
          FULL_IMAGE_NAME: ${{ needs.prepare.outputs.full_image_name }}
          ALL_TAGS: ${{ needs.prepare.outputs.all_tags }}
          SHOULD_BUILD: ${{ needs.prepare.outputs.should_build }}
          BUILT_TAGS: ${{ needs.prepare.outputs.tags_to_build }}
        shell: bash
        run: |
          set -eu

          function __isBuilt() {
            local -r tagName="${1:-}"
            if [[ -z "$tagName" ]]; then
              # Precondition Failure...
              echo "::error:: Empty Tag?!"
              exit 1
            fi

            if [[ "$SHOULD_BUILD" != "true" ]]; then
              return 1
            fi
            while IFS= read -r aBuiltTag; do
              if [[ "$tagName" == "$aBuiltTag" ]]; then
                return 0
              fi
            done < <(echo "$BUILT_TAGS")
            return 1
          }

          declare full_image_tag
          declare -A results=()
          while IFS= read -r aTag; do
            full_image_tag="${FULL_IMAGE_NAME}:${aTag}"
            if __isBuilt "$aTag"; then
              results["$full_image_tag"]="true"
            else
              results["$full_image_tag"]="false"
            fi
          done < <(echo "$ALL_TAGS")

          declare aResult
          echo "results<<__RESULTS__" >>"$GITHUB_OUTPUT"
          for full_image_tag in "${!results[@]}"; do
            aResult=${results["$full_image_tag"]}
            echo "${full_image_tag}=${aResult}" >>"$GITHUB_OUTPUT"
          done
          echo "__RESULTS__" >>"$GITHUB_OUTPUT"


          declare resultsJSON="{"
          declare -r NEWLINE=$'\n'
          for full_image_tag in "${!results[@]}"; do
            aResult=${results["$full_image_tag"]}
            resultsJSON="${resultsJSON}${NEWLINE}  \"${full_image_tag}\": ${aResult},"
          done
          resultsJSON="${resultsJSON%%,}${NEWLINE}}"
          echo "resultsJSON<<__RESULTS_JSON__" >>"$GITHUB_OUTPUT"
          echo "$resultsJSON" >>"$GITHUB_OUTPUT"
          echo "__RESULTS_JSON__" >>"$GITHUB_OUTPUT"
      - name: Generate summary and determine preferred image tag
        id: summary-and-preferred-image-tag
        uses: actions/github-script@v7
        env:
          BUILD_CONTEXT: ${{ inputs.context }}
          BUILD_DOCKERFILE: ${{ inputs.dockerfile || './Dockerfile' }}
          BUILD_ARGS: ${{ inputs.build-args }}
          BUILD_RESULTS: ${{ steps.generate-results.outputs.resultsJSON }}
        with:
          result-encoding: string
          script: |
            const buildResultsJSON = process.env.BUILD_RESULTS;
            const parsedResults = JSON.parse(buildResultsJSON);
            const resultValues = Object.values(parsedResults)
            if (resultValues.length < 1 || !resultValues.every((resultValue) => typeof resultValue == 'boolean')) {
              throw new Error("Unexpected results?!");
            }
            const tagComparator = (tag1, tag2) => {
              if (tag1.includes("latest")) {
                if (!tag2.includes("latest")) {
                  return -1
                }
              }
              if (tag2.includes("latest")) {
                return 1;
              }
              return tag2.localeCompare(tag1);
            };
            const allImageTags = Object.keys(parsedResults).sort((tag1, tag2) => {
              if (parsedResults[tag1] && !parsedResults[tag2]) {
                return -1;
              } else if (!parsedResults[tag1] && parsedResults[tag2]) {
                return 1;
              }
              return tagComparator(tag1, tag2);
            });

            // Generate Summary
            const path = require('path');
            const dockerFilePath = path.join(process.env.BUILD_CONTEXT, process.env.BUILD_DOCKERFILE);
            await core.summary.addHeading(`Build Results for \`${dockerFilePath}\``);
            
            await core.summary.addHeading(
              'Build Arguments', '2'
            ).addList(
              process.env.BUILD_ARGS.split(/\n/).map(arg => arg.trim()).filter(arg => arg.length > 0)
            );

            await core.summary.addHeading(
              'Built Images', '2'
            ).addList(
              allImageTags.map((aTag) => {
                const status = parsedResults[aTag] ? '✅ Built' : '⏭️ Skipped (Already exists)';
                return `\`${aTag}\`: ${status}`
              })
            );
            
            await core.summary.write();

            // Return the result
            return allImageTags[0];
    outputs:
      all-skipped: ${{ needs.prepare.outputs.should_build != 'true' }}
      results: ${{ steps.generate-results.outputs.results }}
      resultsJSON: ${{ steps.generate-results.outputs.resultsJSON }}
      preferred-image-tag: ${{ steps.summary-and-preferred-image-tag.outputs.result }}
