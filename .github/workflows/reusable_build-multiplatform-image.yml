name: Build Multiplatform Image
on:
  workflow_call:
    inputs:
      if-absent:
        description: "A boolean value that indicates whether or not the image should be built only when there's no existing image."
        type: boolean
        required: false
        default: true
      context:
        description: "Build Context"
        type: string
        required: false
        default: "."
      dockerfile:
        description: "Path to the Dockerfile"
        type: string
        required: false
      build-args:
        description: "Build Arguments"
        type: string
        required: false
        default: ""
      registry:
        description: "Docker Registry"
        type: string
        required: false
        default: ""
      username:
        description: "User Name for Docker Registry"
        type: string
        required: false
        default: ""
      image-basename:
        description: "Image Base Name"
        type: string
        required: true
      tags:
        description: "Tag Names (List separated by newlines)"
        type: string
        required: true
      test-command:
        description: "Command to be executed after building the image and before pushing it"
        type: string
        required: false
        default: ""
      test-command-shell:
        description: "Shell to execute the command: `bash` or `zsh`."
        type: string
        required: false
        default: "bash"
      test-script:
        description: "Script to be executed after building the image and before pushing it"
        type: string
        required: false
        default: ""
      push:
        description: "A boolean value indicating whether or not the image is pushed"
        type: boolean
        required: true
        default: false
    secrets:
      password:
        description: "Password to login Docker Registry"
        required: false
    outputs:
      results:
        value: ${{ jobs.generate-results.outputs.results }}
      resultsJSON:
        value: ${{ jobs.generate-results.outputs.resultsJSON }}
jobs:
  generate-image-name-info:
    name: Generate Image Name Info
    runs-on: ubuntu-latest
    steps:
      - name: Generate Image Name Info
        id: image-name-info
        env:
          D_REGISTRY: ${{ inputs.registry }}
          D_USERNAME: ${{ inputs.username }}
          D_IMAGE_BASENAME: ${{ inputs.image-basename }}
          D_TAGS: ${{ inputs.tags }}
        shell: bash
        run: |
          set -eu

          if [[ -z "$D_IMAGE_BASENAME" ]]; then
            echo '::error title=Missing image name::No image base name was given.'
            exit 1
          fi

          declare image_namespace=""
          if [[ -n "$D_REGISTRY" ]]; then
            image_namespace="${image_namespace}${D_REGISTRY,,}/"
          fi
          if [[ -n "$D_USERNAME" ]]; then
            image_namespace="${image_namespace}${D_USERNAME,,}/"
          fi
          image_namespace="${image_namespace%%/}"

          declare full_image_name="${image_namespace}/${D_IMAGE_BASENAME,,}"
          full_image_name="${full_image_name##/}"
          if [[ -z "$full_image_name" ]]; then
            echo '::error::Empty Image Name.'
            exit 1
          fi

          echo "image_namespace=$image_namespace" >>"$GITHUB_OUTPUT"
          echo "full_image_name=$full_image_name" >>"$GITHUB_OUTPUT"

          declare tagLine
          echo "all_tags<<__ALL_TAGS__" >>"$GITHUB_OUTPUT"
          while IFS= read -r tagLine; do
            # Trimming...
            echo "$tagLine" | xargs >>"$GITHUB_OUTPUT"
          done < <(echo "$D_TAGS" | sort -u | awk NF)
          echo "__ALL_TAGS__" >>"$GITHUB_OUTPUT"
    outputs:
      image_namespace: ${{ steps.image-name-info.outputs.image_namespace }}
      full_image_name: ${{ steps.image-name-info.outputs.full_image_name }}
      all_tags: ${{ steps.image-name-info.outputs.all_tags }}
  determine-whether-to-build:
    name: Determine whether or not an image should be built
    needs:
      - generate-image-name-info
    runs-on: ubuntu-latest
    env:
      password: ${{ secrets.password }}
    steps:
      - name: Log in to the Container registry
        if: ${{ inputs.username != '' && env.password != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.username }}
          password: ${{ secrets.password }}
      - name: Determine which image should be built
        id: should-build
        env:
          IF_ABSENT: ${{ (inputs.if-absent && 'true') || 'false' }}
          FULL_IMAGE_NAME: ${{ needs.generate-image-name-info.outputs.full_image_name }}
          ALL_TAGS: ${{ needs.generate-image-name-info.outputs.all_tags }}
        shell: bash
        run: |
          declare should_build="false"
          declare -r tagsToBuildOutput=$(mktemp)
          if [[ "$IF_ABSENT" != "true" ]]; then
            echo "$ALL_TAGS" >>"$tagsToBuildOutput"
            should_build="true"
          else
            set +e
            declare tagLine
            while IFS= read -r tagLine; do
              if [[ "$tagLine" == *latest* ]]; then
                echo "$tagLine" >>"$tagsToBuildOutput"
                should_build="true"
              else
                docker manifest inspect "${FULL_IMAGE_NAME}:${tagLine}"
                if [[ $? -ne 0 ]]; then
                  echo "$tagLine" >>"$tagsToBuildOutput"
                  should_build="true"
                fi
              fi
            done < <(echo "$ALL_TAGS")
          fi

          echo "should_build=$should_build" >>"$GITHUB_OUTPUT"
          echo "tags_to_build<<__TAGS_TO_BUILD__" >>"$GITHUB_OUTPUT"
          cat "$tagsToBuildOutput" >>"$GITHUB_OUTPUT"
          echo "__TAGS_TO_BUILD__" >>"$GITHUB_OUTPUT"
    outputs:
      should_build: ${{ steps.should-build.outputs.should_build }}
      tags_to_build: ${{ steps.should-build.outputs.tags_to_build }}
  build-images:
    name: Build Images (if necessary)
    needs: 
      - generate-image-name-info
      - determine-whether-to-build
    if: ${{ needs.determine-whether-to-build.outputs.should_build == 'true' }}
    env:
      password: ${{ secrets.password }}
    strategy:
      matrix:
        host-os:
          - ubuntu-24.04
          - ubuntu-24.04-arm
    runs-on: ${{ matrix.host-os }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Detect 'arch' and 'platform'
        id: arch-and-platform
        run: |
          case "$(dpkg --print-architecture)" in
          amd64)
            echo "arch=amd64" >>"$GITHUB_OUTPUT"
            echo "platform=linux/amd64" >>"$GITHUB_OUTPUT"
          ;;
          arm64)
            echo "arch=arm64" >>"$GITHUB_OUTPUT"
            echo "platform=linux/arm64" >>"$GITHUB_OUTPUT"
          ;;
          *)
            echo '::error::Unsupported architecture.'
            exit 1
          ;;
          esac
      - name: "Generate `tags` argument for 'docker/metadata-action'"
        id: tags-for-metadata-action
        env:
          D_TAGS: ${{ needs.determine-whether-to-build.outputs.tags_to_build }}
          D_ARCH: ${{ steps.arch-and-platform.outputs.arch }}
        shell: bash
        run: |
          echo "tags<<__TAGS__" >>"$GITHUB_OUTPUT"
          declare tag
          while IFS= read -r tag; do
            echo "type=raw,value=${tag}-${D_ARCH}" >>"$GITHUB_OUTPUT"
          done < <(echo "$D_TAGS")
          echo "__TAGS__" >>"$GITHUB_OUTPUT"
      - name: Generate a tag for tests
        id: test-tag
        shell: bash
        run: |
          declare -r generated_uuid=$(uuidgen)
          echo "test_tag=test-${generated_uuid,,}" >>"$GITHUB_OUTPUT"
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to the Container registry
        if: ${{ inputs.username != '' && env.password != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.username }}
          password: ${{ secrets.password }}
      - name: Extract metadata (tags, labels) for Docker
        id: metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.generate-image-name-info.outputs.full_image_name }}
          tags: ${{ steps.tags-for-metadata-action.outputs.tags }}
      - name: Build Image
        id: build-image
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          build-args: ${{ inputs.build-args }}
          platforms: ${{ steps.arch-and-platform.outputs.platform }}
          load: true
          push: false
          tags: |
            ${{ steps.metadata.outputs.tags }}
            ${{ needs.generate-image-name-info.outputs.full_image_name }}:${{ steps.test-tag.outputs.test_tag }}
          labels: ${{ steps.metadata.outputs.labels }}
          provenance: false
          sbom: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Test Image (Command)
        if: ${{ inputs.test-command != '' }}
        # Workaround for 'shell' not taking `${{ ... }}`
        env:
          TEST_COMMAND_SHELL: ${{ inputs.test-command-shell }}
          TEST_COMMAND: ${{ inputs.test-command }}
          DOCKER_TEST_TAG: "${{ needs.generate-image-name-info.outputs.full_image_name }}:${{ steps.test-tag.outputs.test_tag }}"
        run: |
          case "$TEST_COMMAND_SHELL" in
          bash)
            bash -c "$TEST_COMMAND"
          ;;
          zsh)
            sudo apt update && sudo apt install zsh
            zsh -c "$TEST_COMMAND"
          ;;
          *)
            echo '::error::Unsupported shell.'
            exit 1
          ;;
          esac
      - name: Test Image (Script File)
        if: ${{ inputs.test-script != '' }}
        env:
          DOCKER_TEST_TAG: "${{ needs.generate-image-name-info.outputs.full_image_name }}:${{ steps.test-tag.outputs.test_tag }}"
        run: |
          if [[ ! -f "${{ inputs.test-script }}" ]]; then
            echo '::error title=Missing test script::Script file not found.'
            exit 1
          fi
          chmod a+x "${{ inputs.test-script }}"
          "${{ inputs.test-script }}"
      - name: Push Image
        id: push-image
        if: ${{ inputs.push }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          build-args: ${{ inputs.build-args }}
          platforms: ${{ steps.arch-and-platform.outputs.platform }}
          load: false
          push: true
          tags: ${{ steps.metadata.outputs.tags }}
          labels: ${{ steps.metadata.outputs.labels }}
          provenance: false
          sbom: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
  merge-images:
    name: Merge Images (if necessary)
    needs:
      - generate-image-name-info
      - determine-whether-to-build
      - build-images
    if: ${{ inputs.push && needs.determine-whether-to-build.outputs.should_build == 'true' }}
    runs-on:
      - ubuntu-latest
    env:
      password: ${{ secrets.password }}
    steps:
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to the Container registry
        if: ${{ inputs.username != '' && env.password != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.username }}
          password: ${{ secrets.password }}
      - name: Merge Images
        env:
          FULL_IMAGE_NAME: ${{ needs.generate-image-name-info.outputs.full_image_name }}
          BUILT_TAGS: ${{ needs.determine-whether-to-build.outputs.tags_to_build }}
        shell: bash
        run: |
          declare tagLine
          declare full_image_tag
          while IFS= read -r tagLine; do
            full_image_tag="${FULL_IMAGE_NAME}:${tagLine}"
            docker manifest create "$full_image_tag" \
              "${full_image_tag}-amd64" \
              "${full_image_tag}-arm64"
            docker manifest annotate "$full_image_tag" \
              "${full_image_tag}-amd64" --os linux --arch amd64
            docker manifest annotate "$full_image_tag" \
              "${full_image_tag}-arm64" --os linux --arch arm64
            docker manifest push "$full_image_tag"
          done < <(echo "$BUILT_TAGS")
  generate-results:
    name: Generate Results
    needs:
      - generate-image-name-info
      - determine-whether-to-build
      - merge-images
    if: ${{ ! failure() }}
    runs-on: ubuntu-latest
    steps:
      - name: Generate Results
        id: generate-results
        env:
          FULL_IMAGE_NAME: ${{ needs.generate-image-name-info.outputs.full_image_name }}
          ALL_TAGS: ${{ needs.generate-image-name-info.outputs.all_tags }}
          SHOULD_BUILD: ${{ needs.determine-whether-to-build.outputs.should_build }}
          BUILT_TAGS: ${{ needs.determine-whether-to-build.outputs.tags_to_build }}
        shell: bash
        run: |
          set -eu

          function __isBuilt() {
            local -r tagName="${1:-}"
            if [[ -z "$tagName" ]]; then
              # Precondition Failure...
              echo "::error:: Empty Tag?!"
              exit 1
            fi

            if [[ "$SHOULD_BUILD" != "true" ]]; then
              return 1
            fi
            while IFS= read -r aBuiltTag; do
              if [[ "$tagName" == "$aBuiltTag" ]]; then
                return 0
              fi
            done < <(echo "$BUILT_TAGS")
            return 1
          }

          declare full_image_tag
          declare -A results=()
          while IFS= read -r aTag; do
            full_image_tag="${FULL_IMAGE_NAME}:${aTag}"
            if __isBuilt "$aTag"; then
              results["$full_image_tag"]="true"
            else
              results["$full_image_tag"]="false"
            fi
          done < <(echo "$ALL_TAGS")

          declare aResult
          echo "results<<__RESULTS__" >>"$GITHUB_OUTPUT"
          for full_image_tag in "${!results[@]}"; do
            aResult=${results["$full_image_tag"]}
            echo "${full_image_tag}=${aResult}" >>"$GITHUB_OUTPUT"
          done
          echo "__RESULTS__" >>"$GITHUB_OUTPUT"


          declare resultsJSON="{"
          declare -r NEWLINE=$'\n'
          for full_image_tag in "${!results[@]}"; do
            aResult=${results["$full_image_tag"]}
            resultsJSON="${resultsJSON}${NEWLINE}  \"${full_image_tag}\": ${aResult},"
          done
          resultsJSON="${resultsJSON%%,}${NEWLINE}}"
          echo "resultsJSON<<__RESULTS_JSON__" >>"$GITHUB_OUTPUT"
          echo "$resultsJSON" >>"$GITHUB_OUTPUT"
          echo "__RESULTS_JSON__" >>"$GITHUB_OUTPUT"
    outputs:
      results: ${{ steps.generate-results.outputs.results }}
      resultsJSON: ${{ steps.generate-results.outputs.resultsJSON }}
